#include <cstdlib>
#include <ctime>
#include <stdint.h>

#include "core/rv32/elf_loader.h"
#include "core/rv32/iss.h"
#include "core/rv32/mem.h"

#include <boost/io/ios_state.hpp>
#include <boost/program_options.hpp>
#include <iomanip>
#include <iostream>
#include <fstream>

using namespace rv32;


struct EmptyMemoryInterface : public instr_memory_if, public data_memory_if {
	uint32_t load_instr(uint64_t addr) {
		throw std::runtime_error("not implemented");
	}

	int32_t load_word(uint64_t addr) {
		throw std::runtime_error("not implemented");
	}
	int32_t load_half(uint64_t addr) {
		throw std::runtime_error("not implemented");
	}
	int32_t load_byte(uint64_t addr) {
		throw std::runtime_error("not implemented");
	}
	uint32_t load_uhalf(uint64_t addr) {
		throw std::runtime_error("not implemented");
	}
	uint32_t load_ubyte(uint64_t addr) {
		throw std::runtime_error("not implemented");
	}

	void store_word(uint64_t addr, uint32_t value) {
		throw std::runtime_error("not implemented");
	}
	void store_half(uint64_t addr, uint16_t value) {
		throw std::runtime_error("not implemented");
	}
	void store_byte(uint64_t addr, uint8_t value) {
		throw std::runtime_error("not implemented");
	}

	virtual int32_t atomic_load_word(uint64_t addr) {
		throw std::runtime_error("not implemented");
	}
	virtual void atomic_store_word(uint64_t addr, uint32_t value) {
		throw std::runtime_error("not implemented");
	}
	virtual int32_t atomic_load_reserved_word(uint64_t addr) {
		throw std::runtime_error("not implemented");
	}
	virtual bool atomic_store_conditional_word(uint64_t addr, uint32_t value) {
		throw std::runtime_error("not implemented");
	}
	virtual void atomic_unlock() {
		throw std::runtime_error("not implemented");
	}
};



struct InstrBuilder {
	
	static inline uint32_t LUI(unsigned rd, unsigned U_imm) {
		return (U_imm & (1048575 << 12)) | ((rd & 0x1f) << 7) | 0b0110111;
	}
	
	static inline uint32_t AUIPC(unsigned rd, unsigned U_imm) {
		return (U_imm & (1048575 << 12)) | ((rd & 0x1f) << 7) | 0b0010111;
	}
	
	
	static inline uint32_t JAL(unsigned rd, int J_imm) {
		return 0b1101111 | ((rd & 0x1f) << 7) | ((J_imm & (0b11111111 << 12)) | ((J_imm & (1 << 11)) << 9) | ((J_imm & 0b11111111110) << 20) | ((J_imm & (1 << 20)) << 11))
	}
	
	static inline uint32_t JALR(unsigned rd, unsigned rs1, int I_imm) {
		return (I_imm & 4095) << 20) | ((rd & 0x1f) << 7) | ((rs1 & 0x1f) << 15) | 103;
	}
	
	
	static inline uint32_t _branch_format(unsigned rs1, unsigned rs2, int B_imm) {
		return ((((B_imm & 0b11110) << 7) | ((B_imm & (1 << 11)) >> 4)) | (((B_imm & (0b111111 << 5)) << 20) | ((B_imm & (1 << 12)) << 19))) | ((rs1 & 0x1f) << 15) | ((rs2 & 0x1f) << 20) | 0b1100011;
	}
	
	static inline uint32_t BEQ(unsigned rs1, unsigned rs2, int B_imm) {
		return _branch_format(rs1, rs2, B_imm) | (0b000 << 12);
	}
	
	static inline uint32_t BNE(unsigned rs1, unsigned rs2, int B_imm) {
		return _branch_format(rs1, rs2, B_imm) | (0b001 << 12);
	}
	
	static inline uint32_t BLT(unsigned rs1, unsigned rs2, int B_imm) {
		return _branch_format(rs1, rs2, B_imm) | (0b100 << 12);
	}
	
	static inline uint32_t BGE(unsigned rs1, unsigned rs2, int B_imm) {
		return _branch_format(rs1, rs2, B_imm) | (0b101 << 12);
	}
	
	static inline uint32_t BLTU(unsigned rs1, unsigned rs2, int B_imm) {
		return _branch_format(rs1, rs2, B_imm) | (0b110 << 12);
	}
	
	static inline uint32_t BGEU(unsigned rs1, unsigned rs2, int B_imm) {
		return _branch_format(rs1, rs2, B_imm) | (0b111 << 12);
	}
	
	
	static inline uint32_t LB(unsigned rd, unsigned rs1, int I_imm) {
		return ((I_imm & 4095) << 20) | ((rd & 0x1f) << 7) | ((rs1 & 0x1f) << 15) | 0b0000011 | (0b000 << 12);
	}
	
	static inline uint32_t LH(unsigned rd, unsigned rs1, int I_imm) {
		return ((I_imm & 4095) << 20) | ((rd & 0x1f) << 7) | ((rs1 & 0x1f) << 15) | 0b0000011 | (0b001 << 12);
	}
	
	static inline uint32_t LW(unsigned rd, unsigned rs1, int I_imm) {
		return ((I_imm & 4095) << 20) | ((rd & 0x1f) << 7) | ((rs1 & 0x1f) << 15) | 0b0000011 | (0b010 << 12);
	}
	
	static inline uint32_t LBU(unsigned rd, unsigned rs1, int I_imm) {
		return ((I_imm & 4095) << 20) | ((rd & 0x1f) << 7) | ((rs1 & 0x1f) << 15) | 0b0000011 | (0b100 << 12);
	}
	
	static inline uint32_t LHU(unsigned rd, unsigned rs1, int I_imm) {
		return ((I_imm & 4095) << 20) | ((rd & 0x1f) << 7) | ((rs1 & 0x1f) << 15) | 0b0000011 | (0b101 << 12);
	}
	
	static inline uint32_t SB(unsigned rs1, unsigned rs2, int S_imm) {
		return (((S_imm & 0b11111) << 7) | ((S_imm & (0b1111111 << 5)) << 20)) | ((rs1 & 0x1f) << 15) | ((rs2 & 0x1f) << 20) | 0b0100011 | (0b000 << 12);
	}
	
	static inline uint32_t SH(unsigned rs1, unsigned rs2, int S_imm) {
		return (((S_imm & 0b11111) << 7) | ((S_imm & (0b1111111 << 5)) << 20)) | ((rs1 & 0x1f) << 15) | ((rs2 & 0x1f) << 20) | 0b0100011 | (0b001 << 12);
	}
	
	static inline uint32_t SW(unsigned rs1, unsigned rs2, int S_imm) {
		return (((S_imm & 0b11111) << 7) | ((S_imm & (0b1111111 << 5)) << 20)) | ((rs1 & 0x1f) << 15) | ((rs2 & 0x1f) << 20) | 0b0100011 | (0b010 << 12);
	}
	
	
	static inline uint32_t ADDI(unsigned rd, unsigned rs1, int I_imm) {
		return ((I_imm & 4095) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0010011;
	}
	
	static inline uint32_t SLTI(unsigned rd, unsigned rs1, int imm) {
		return ((I_imm & 4095) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0010011 | (0b010 << 12);
	}
	
	static inline uint32_t SLTI(unsigned rd, unsigned rs1, int imm) {
		return ((I_imm & 4095) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0010011 | (0b011 << 12);
	}
	
	static inline uint32_t XORI(unsigned rd, unsigned rs1, int imm) {
		return ((I_imm & 4095) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0010011 | (0b100 << 12);
	}
	
	static inline uint32_t ORI(unsigned rd, unsigned rs1, int imm) {
		return ((I_imm & 4095) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0010011 | (0b110 << 12);
	}
	
	static inline uint32_t ANDI(unsigned rd, unsigned rs1, int imm) {
		return ((I_imm & 4095) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0010011 | (0b111 << 12);
	}
	
	
	static inline uint32_t SLLI(unsigned rd, unsigned rs1, unsigned shamt) {
		return ((shamt & 0x1f) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0010011 | (0b001 << 12);
	}
	
	static inline uint32_t SRLI(unsigned rd, unsigned rs1, unsigned shamt) {
		return ((shamt & 0x1f) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0010011 | (0b101 << 12);
	}
	
	static inline uint32_t SRAI(unsigned rd, unsigned rs1, unsigned shamt) {
		return ((shamt & 0x1f) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0010011 | (0b101 << 12) | (0b0100000 << 25);
	}


	static inline uint32_t ADD(unsigned rd, unsigned rs1, unsigned rs2) {
		return ((rs2 & 0x1f) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0110011;
	}
	
	static inline uint32_t SUB(unsigned rd, unsigned rs1, unsigned rs2) {
		return ((rs2 & 0x1f) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0110011 | (0b0100000 << 25);
	}
	
	static inline uint32_t SLL(unsigned rd, unsigned rs1, unsigned rs2) {
		return ((rs2 & 0x1f) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0110011 | (0b001 << 12);
	}
	
	static inline uint32_t SLT(unsigned rd, unsigned rs1, unsigned rs2) {
		return ((rs2 & 0x1f) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0110011 | (0b010 << 12);
	}
	
	static inline uint32_t SLTU(unsigned rd, unsigned rs1, unsigned rs2) {
		return ((rs2 & 0x1f) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0110011 | (0b011 << 12);
	}
	
	static inline uint32_t XOR(unsigned rd, unsigned rs1, unsigned rs2) {
		return ((rs2 & 0x1f) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0110011 | (0b100 << 12);
	}

	static inline uint32_t SRL(unsigned rd, unsigned rs1, unsigned rs2) {
		return ((rs2 & 0x1f) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0110011 | (0b101 << 12);
	}
	
	static inline uint32_t SRA(unsigned rd, unsigned rs1, unsigned rs2) {
		return ((rs2 & 0x1f) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0110011 | (0b101 << 12) | (0b0100000 << 25);
	}
	
	static inline uint32_t OR(unsigned rd, unsigned rs1, unsigned rs2) {
		return ((rs2 & 0x1f) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0110011 | (0b110 << 12);
	}
	
	static inline uint32_t AND(unsigned rd, unsigned rs1, unsigned rs2) {
		return ((rs2 & 0x1f) << 20) | ((rs1 & 0x1f) << 15) | ((rd & 0x1f) << 7) | 0b0110011 | (0b111 << 12);
	}

};


constexpr static unsigned zero = 0;


struct CodeBuilder {
	std::vector<uint32_t> code;
	unsigned idx = 0;
	
	void clear() {
		code.clear();
		idx = 0;
	}
	
	uint32_t next() {
		return code[idx++];
	}
	
	bool has_next() {
		return idx < code.size();
	}
	
	
	/* RV32I instructions */
	
	void LUI(unsigned rd, unsigned imm) {
		code.push_back(InstrBuilder::LUI(rd, imm));
	}
	
	void AUIPC(unsigned rd, unsigned imm) {
		code.push_back(InstrBuilder::LUI(rd, imm));
	}
	
	
	void JAL(unsigned rd, int imm) {
		code.push_back(InstrBuilder::JAL(rd, imm));
	}
	
	void JALR(unsigned rd, unsigned rs1, int imm) {
		code.push_back(InstrBuilder::JALR(rd, rs1, imm));
	}
	
	
	void BEQ(unsigned rs1, unsigned rs2, int imm) {
		code.push_back(InstrBuilder::BEQ(rs1, rs2, imm));
	}
	
	void BNE(unsigned rs1, unsigned rs2, int imm) {
		code.push_back(InstrBuilder::BNE(rs1, rs2, imm));
	}
	
	void BLT(unsigned rs1, unsigned rs2, int imm) {
		code.push_back(InstrBuilder::BLT(rs1, rs2, imm));
	}
	
	void BGE(unsigned rs1, unsigned rs2, int imm) {
		code.push_back(InstrBuilder::BGE(rs1, rs2, imm));
	}
	
	void BLTU(unsigned rs1, unsigned rs2, int imm) {
		code.push_back(InstrBuilder::BLTU(rs1, rs2, imm));
	}
	
	void BGEU(unsigned rs1, unsigned rs2, int imm) {
		code.push_back(InstrBuilder::BGEU(rs1, rs2, imm));
	}
	
	
	void LB(unsigned rd, unsigned rs1, int imm) {
		code.push_back(InstrBuilder::LB(rd, rs1, imm));
	}
	
	void LH(unsigned rd, unsigned rs1, int imm) {
		code.push_back(InstrBuilder::LH(rd, rs1, imm));
	}
	
	void LW(unsigned rd, unsigned rs1, int imm) {
		code.push_back(InstrBuilder::LW(rd, rs1, imm));
	}
	
	void LBU(unsigned rd, unsigned rs1, int imm) {
		code.push_back(InstrBuilder::LBU(rd, rs1, imm));
	}
	
	void LHU(unsigned rd, unsigned rs1, int imm) {
		code.push_back(InstrBuilder::LHU(rd, rs1, imm));
	}
	
	void SB(unsigned rs1, unsigned rs2, int imm) {
		code.push_back(InstrBuilder::SB(rs1, rs2, imm));
	}
	
	void SH(unsigned rs1, unsigned rs2, int imm) {
		code.push_back(InstrBuilder::SH(rs1, rs2, imm));
	}
	
	void SW(unsigned rs1, unsigned rs2, int imm) {
		code.push_back(InstrBuilder::SW(rs1, rs2, imm));
	}
	
	
	void ADDI(unsigned rd, unsigned rs1, int imm) {
		code.push_back(InstrBuilder::ADDI(rd, rs1, imm));
	}
	
	void SLTI(unsigned rd, unsigned rs1, int imm) {
		code.push_back(InstrBuilder::SLTI(rd, rs1, imm));
	}
	
	void SLTIU(unsigned rd, unsigned rs1, int imm) {
		code.push_back(InstrBuilder::SLTIU(rd, rs1, imm));
	}
	
	void XORI(unsigned rd, unsigned rs1, int imm) {
		code.push_back(InstrBuilder::XORI(rd, rs1, imm));
	}
	
	void ORI(unsigned rd, unsigned rs1, int imm) {
		code.push_back(InstrBuilder::ORI(rd, rs1, imm));
	}
	
	void ANDI(unsigned rd, unsigned rs1, int imm) {
		code.push_back(InstrBuilder::ANDI(rd, rs1, imm));
	}
	
	void SLLI(unsigned rd, unsigned rs1, unsigned shamt) {
		code.push_back(InstrBuilder::SLLI(rd, rs1, shamt));
	}
	
	void SRLI(unsigned rd, unsigned rs1, unsigned shamt) {
		code.push_back(InstrBuilder::SRLI(rd, rs1, shamt));
	}
	
	void SRAI(unsigned rd, unsigned rs1, unsigned shamt) {
		code.push_back(InstrBuilder::SRAI(rd, rs1, shamt));
	}


	void ADD(unsigned rd, unsigned rs1, unsigned rs2) {
		code.push_back(InstrBuilder::ADD(rd, rs1, rs2));
	}
	
	void SUB(unsigned rd, unsigned rs1, unsigned rs2) {
		code.push_back(InstrBuilder::SUB(rd, rs1, rs2));
	}
	
	void SLL(unsigned rd, unsigned rs1, unsigned rs2) {
		code.push_back(InstrBuilder::SLL(rd, rs1, rs2));
	}
	
	void SLT(unsigned rd, unsigned rs1, unsigned rs2) {
		code.push_back(InstrBuilder::SLT(rd, rs1, rs2));
	}
	
	void SLTU(unsigned rd, unsigned rs1, unsigned rs2) {
		code.push_back(InstrBuilder::SLTU(rd, rs1, rs2));
	}
	
	void XOR(unsigned rd, unsigned rs1, unsigned rs2) {
		code.push_back(InstrBuilder::XOR(rd, rs1, rs2));
	}
	
	void SRL(unsigned rd, unsigned rs1, unsigned rs2) {
		code.push_back(InstrBuilder::SRL(rd, rs1, rs2));
	}
	
	void SRA(unsigned rd, unsigned rs1, unsigned rs2) {
		code.push_back(InstrBuilder::SRA(rd, rs1, rs2));
	}
	
	void OR(unsigned rd, unsigned rs1, unsigned rs2) {
		code.push_back(InstrBuilder::OR(rd, rs1, rs2));
	}
	
	void AND(unsigned rd, unsigned rs1, unsigned rs2) {
		code.push_back(InstrBuilder::AND(rd, rs1, rs2));
	}


	/* RV32I pseudo-instructions */
	
	void LI(unsigned rd, int imm) {
		if (imm >= -2048 && imm <= 4095) {
			ADDI(rd, zero, imm);
		} else {
			ADDI(rd, zero, imm & 4095);
			LUI(rd, imm >> 12);
		}
	}
	
	void MV(unsigned rd, unsigned rs) {
		ADD(rd, rs, zero);
	}
};



struct Random {
	unsigned operator() (unsigned n) {
		return rand() % n;
	}

	unsigned u_imm() {
		return rand() % 1048576;
	}
	
	int i_imm() {
		return rand() % 4096;
	}
	
	int s_imm() {
		return rand() % 4096;
	}
	
	int b_imm() {
		return (rand() % 4096) << 1;
	}
	
	int j_imm() {
		return (rand() % 1048576) << 1;
	}
	
	uint32_t reg_val() {
		return rand() % 0xffffffff;
	}
	
	unsigned reg() {
		return rand() % 32;
	}
	
	unsigned non_zero_reg() {
		return (rand() % 31) + 1;
	}
	
	
	unsigned unique_reg(unsigned r1) {
		unsigned ans = reg();
		while (ans == r1)
			ans = (ans + 1) % 32;
		return ans;
	}
	
	unsigned unique_reg(unsigned r1, unsigned r2) {
		unsigned ans = reg();
		while (ans == r1 || ans == r2)
			ans = (ans + 1) % 32;
		return ans;
	}
	
	unsigned unique_reg(unsigned r1, unsigned r2, unsigned r3) {
		unsigned ans = reg();
		while (ans == r1 || ans == r2 || ans == r3)
			ans = (ans + 1) % 32;
		return ans;
	}
	
	unsigned unique_reg(unsigned r1, unsigned r2, unsigned r3, unsigned r4) {
		unsigned ans = reg();
		while (ans == r1 || ans == r2 || ans == r3 || ans == r4)
			ans = (ans + 1) % 32;
		return ans;
	}
	
	unsigned unique_reg(unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5) {
		unsigned ans = reg();
		while (ans == r1 || ans == r2 || ans == r3 || ans == r4 || ans == r5)
			ans = (ans + 1) % 32;
		return ans;
	}
	
	unsigned unique_reg(unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5, unsigned r6) {
		unsigned ans = reg();
		while (ans == r1 || ans == r2 || ans == r3 || ans == r4 || ans == r5 || ans == r6)
			ans = (ans + 1) % 32;
		return ans;
	}
	
	unsigned unique_reg(std::initializer_list<unsigned> xs) {
		assert (xs.size() < 32);
		unsigned ans = reg();
		while (std::any_of(xs.begin(), xs.end(), [ans](unsigned i){return i==ans;}))
			ans = (ans + 1) % 32;
		return ans;
	}
};



struct Executor : public EmptyMemoryInterface {
	ISS &core;
	Random &random;
	CodeBuilder code;
	
	Executor(ISS &core, Random &random) 
		: core(core), random(random) {
		core.instr_mem = this;
	}
	
	uint32_t load_instr(uint64_t addr) {
		return code.next();
	}
	
	uint32_t run(unsigned rd=0) {
		assert (code.has_next());
		
		while (code.has_next()) {
			core.run_step();
		}
		
		code.clear();
		
		return core.regs[rd];
	}
	
	uint32_t get_reg(unsigned idx) {
		return core.regs[idx];
	}
	
	void check(bool cond) {
		if (!cond)
			throw std::runtime_error("ERROR: rule check failed");
	}
	
	/* ADD Rules */
	
	void ADD_R1(unsigned rd, unsigned rs1, unsigned rs2) {
		// a + b == b + a
		
		unsigned rx, ry;

		if (rd == rs1) {
			rx = random_unique_reg(rd, rs1, rs2, 0);
			code.MV(rx, rs1);
		} else {
			rx = rs1;
		}
	
		if (rd == rs2) {
			ry = random_unique_reg(rd, rs1, rs2, rx, 0);
			code.MV(ry, rs2);
		} else {
			ry = rs2;
		}
		
		code.ADD(rd, rs1, rs2);
		auto v1 = run(rd);
	
		code.ADD(rd, ry, rx);
		auto v2 = run(rd);
	
		check(v1 == v2);
	}
	
	
	void ADD_R1(unsigned rd, unsigned rs1, unsigned rs2) {
		// a + b == a + ceil(b/2) + floor(b/2)
		//
		// ceil(b/2)  == (b >> 1) + (b & 1)
		// floor(b/2) == (b >> 1)

		unsigned rx, ry, rz;

		if (rd == rs1) {
			rx = random_unique_reg(rd, rs1, rs2, 0);
			code.MV(rx, rs1);
		} else {
			rx = rs1;
		}
	
		if (rd == rs2) {
			ry = random_unique_reg(rd, rs1, rs2, rx, 0);
			code.MV(ry, rs2);
		} else {
			ry = rs2;
		}
		
		rz = random_unique_reg(rd, rs1, rs2, rx, ry, 0);
		
		code.ADD(rd, rs1, rs2);
		auto v1 = run(rd);
		
		
		code.SRLI(rz, ry, 1);	// floor(b/2)
		code.ADD(rd, rx, rz);	// a + floor(b/2)
		
		code.ANDI(ry, ry, 1);	// b % 2 == 1 ?
		code.ADD(ry, ry, rz);	// ceil(b/2)
		code.ADD(rd, ry, rd);
		auto v2 = run(rd);
	
		check(v1 == v2);
	}
	
	
	/* LUI Rules */
	
	void LUI_R1(unsigned rd, uint32_t imm) {
		code.LUI(rd, imm);
		auto v1 = run(rd);
	
		auto rx = random.unique_reg(rd, zero);
	
		code.ADDI(rd, zero, imm >> 8);
		code.SLLI(rd, rd, 20);
		code.ORI(rx, zero, imm & 0xff);
		code.SLLI(rx, rx, 12);
		code.OR(rd, rx, rd);
		auto v2 = run(rd);
	
		check(v1 == v2);
	}
	
	void LUI_R2(unsigned rd, uint32_t imm) {
		code.LUI(rd, imm);
		auto v = run(rd);
		check(rd == 0 ? v == 0 : v == (imm << 12));
	}
	
	/* SLL Rules */
	
	void SLL_R1(unsigned rs) {
		// left rotate by 32 bit produces the same number
		
		auto rd = random.unique_reg(rs, zero);
		auto v1 = get_reg(rs);
		
		for (unsigned i=0; i<32; ++i) {
			code.SRLI(rd, rs, 31);
			code.SLLI(rs, rs, 1);
			code.OR(rs, rs, rd);
			run();
		}
		
		auto v2 = get_reg(rs);
		check(v1 == v2);
	}
	
	void SLL_R2(unsigned rd, unsigned rs1, unsigned rs2) {
		// 
		
		auto v_rs1 = get_reg(rs1);
		auto v_rs2 = get_reg(rs2);
		
		code.SLL(rd, rs1, rs2);
		run();
		
		auto v_rd = get_reg(rd);
		
		if (pre_rs1 == 0)
			check(v_rd == 0);
		else if (pre_rs2 == 0)
			check(v_rd == v_rs1);
		else if (rd != rs1)
			check(v_rd != v_rs1);
	}
};



struct test_rule_if {
	virtual ~test_rule_if() {}
	
	virtual void randomize(Random &random) = 0;
	
	virtual void run(Executor &exec) = 0;
};


struct LUI_Base : public test_rule_if {
	unsigned rd;
	uint32_t imm;
	
	void randomize(Random &random) {
		rd = random.reg();
		imm = random.u_imm();
	}
};

struct LUI_R1 : public LUI_Base {	
	void run(Executor &exec) {
		exec.LUI_R1(rd, imm);
	}
};

struct LUI_R2 : public LUI_Base {	
	void run(Executor &exec) {
		exec.LUI_R2(rd, imm);
	}
};


struct ADD_R1 : public test_rule_if {
	unsigned rd, rs1, rs2;
	uint32_t a, b;
	
	void randomize(Random &random) {
		rd = random.reg();
		rs1 = random.reg();
		rs2 = random.reg();
		a = random.reg_val();
		b = random.reg_val();
	}
	
	void run(Executor &exec) {
		exec.LoadReg(rs1, a);
		exec.LoadReg(rs2, b);
		exec.ADD_R1(rd, rs1, rs2);
	}
};


struct ADD_R2 : public test_rule_if {
	unsigned rd, rs1, rs2;
	uint32_t a, b;
	
	void randomize(Random &random) {
		rd = random.reg();
		rs1 = random.reg();
		rs2 = random.reg();
		a = random.reg_val();
		b = random.reg_val();
	}
	
	void run(Executor &exec) {
		exec.LoadReg(rs1, a);
		exec.LoadReg(rs2, b);
		exec.ADD_R2(rd, rs1, rs2);
	}
};


std::shared_ptr<test_rule_if> random_rule(Random &random) {
	switch (random(2)) {
		case 0:
			return std::make_shared<LUI_R1>();
			
		case 1:
			return std::make_shared<LUI_R2>();
			
		default:
			assert (false);
	}

}


int main(int argc, char **argv) {
    ISS core(0, false);
    Random random;
    Executor exec(core, random);
    
    core.randomize_state();
    //core.trace = true;
    
    for (int i=0; i<10000; ++i) {
		auto rule = random_rule(random);
		rule->randomize(random);
		rule->run(exec);
    }
    
	core.show();

    return 0;
}
